import streamlit as st
import pandas as pd
import pickle
import plotly.express as px

# --- Page Configuration ---
st.set_page_config(
    page_title="Market Basket Analysis (Eclat)",
    page_icon="ðŸ›’",
    layout="wide"
)

# --- Load Data Function ---
@st.cache_data
def load_data(filepath):
    """
    Loads the pickle file containing Eclat results.
    Expected structure: A dictionary with keys like 'support_dictionary'
    """
    try:
        with open(filepath, 'rb') as f:
            data = pickle.load(f)
        return data
    except FileNotFoundError:
        st.error(f"File not found: {filepath}. Please ensure 'eclat_results.pkl' is in the same directory.")
        return None
    except Exception as e:
        st.error(f"Error loading pickle file: {e}")
        return None

# --- Main Application Logic ---
def main():
    st.title("ðŸ›’ Market Basket Analysis: Eclat Results")
    st.markdown("""
    This application visualizes frequent itemsets generated by the Eclat algorithm.
    Use the sidebar to filter results based on Support and specific items.
    """)

    # Load Data
    raw_data = load_data('eclat_results.pkl')

    if raw_data:
        # Extract the support dictionary
        # The pickle dump suggests keys might be "support_dictionary" or "frequent_itemsets"
        # We handle likely keys:
        if isinstance(raw_data, dict):
            if 'support_dictionary' in raw_data:
                support_data = raw_data['support_dictionary']
            elif 'frequent_itemsets' in raw_data:
                # Fallback if dictionary structure is different
                support_data = raw_data['frequent_itemsets']
            else:
                st.warning("Could not identify 'support_dictionary' key. displaying raw keys.")
                st.write(raw_data.keys())
                return
        else:
            # If the pickle is just the dictionary itself
            support_data = raw_data

        # Convert dictionary to DataFrame
        # Data structure assumption: { (item1, item2): support_float, ... }
        try:
            # Flatten itemsets into strings for display
            items = []
            supports = []
            
            for itemset, support in support_data.items():
                # Handle cases where itemset is a tuple/frozenset or single string
                if isinstance(itemset, (tuple, frozenset, list)):
                    items.append(", ".join(list(itemset)))
                else:
                    items.append(str(itemset))
                supports.append(support)

            df = pd.DataFrame({'Itemset': items, 'Support': supports})
            
            # Sort by Support descending
            df = df.sort_values(by='Support', ascending=False).reset_index(drop=True)

        except Exception as e:
            st.error(f"Error processing data structure: {e}")
            st.write("Raw Data Sample:", list(support_data.items())[:5])
            return

        # --- Sidebar ---
        st.sidebar.header("Filter Results")

        # 1. Min Support Slider
        min_support = df['Support'].min()
        max_support = df['Support'].max()
        
        selected_min_support = st.sidebar.slider(
            "Minimum Support Threshold",
            min_value=float(min_support),
            max_value=float(max_support),
            value=float(min_support),
            format="%.4f"
        )

        # 2. Item Search
        unique_items = set()
        for item_str in df['Itemset']:
            for single_item in item_str.split(", "):
                unique_items.add(single_item)
        
        selected_items = st.sidebar.multiselect(
            "Filter by Specific Item(s)",
            options=sorted(list(unique_items))
        )

        # --- Filtering Logic ---
        filtered_df = df[df['Support'] >= selected_min_support]

        if selected_items:
            # Filter rows that contain ALL selected items
            # pattern = '|'.join(selected_items) # OR logic
            # filtered_df = filtered_df[filtered_df['Itemset'].str.contains(pattern)]
            
            # AND logic (Itemset must contain at least one of the selected items usually preferred for exploration)
            # Let's do: Show itemsets that contain ANY of the selected items
            mask = filtered_df['Itemset'].apply(lambda x: any(item in x for item in selected_items))
            filtered_df = filtered_df[mask]

        # --- Dashboard Metrics ---
        col1, col2, col3 = st.columns(3)
        col1.metric("Total Itemsets Found", len(df))
        col2.metric("Filtered Itemsets", len(filtered_df))
        col3.metric("Highest Support", f"{df['Support'].max():.4f}")

        # --- Visualizations ---
        st.subheader(f"Top Frequent Itemsets (Support >= {selected_min_support:.4f})")
        
        tab1, tab2 = st.tabs(["ðŸ“Š Bar Chart", "ðŸ“„ Data Table"])

        with tab1:
            if not filtered_df.empty:
                # Limit to top 20 for readability in chart
                top_n = 20
                chart_df = filtered_df.head(top_n)
                
                fig = px.bar(
                    chart_df,
                    x='Support',
                    y='Itemset',
                    orientation='h',
                    title=f"Top {top_n} Frequent Itemsets by Support",
                    color='Support',
                    color_continuous_scale='Viridis'
                )
                fig.update_layout(yaxis={'categoryorder': 'total ascending'})
                st.plotly_chart(fig, use_container_width=True)
            else:
                st.info("No itemsets meet the current filter criteria.")

        with tab2:
            st.dataframe(
                filtered_df.style.background_gradient(subset=['Support'], cmap="Greens"),
                use_container_width=True
            )

if __name__ == "__main__":
    main()
