import streamlit as st
import pandas as pd
import pickle
import plotly.express as px
import requests
import io

# --- Page Configuration ---
st.set_page_config(
    page_title="Market Basket Analysis (Eclat)",
    page_icon="ðŸ›’",
    layout="wide"
)

# --- Constants ---
# We use the 'raw' version of the GitHub URL to get the actual file content
GITHUB_URL = "https://github.com/sudhr-gitthub/ML_Projects/raw/main/Groceries_Billing/Eclat/eclat_results.pkl"

# --- Load Data Function ---
@st.cache_data
def load_data_from_github(url):
    """
    Fetches the pickle file directly from a GitHub raw URL.
    """
    try:
        response = requests.get(url)
        response.raise_for_status()  # Check for HTTP errors (e.g., 404)
        
        # specific to pickle: we need to wrap the binary content in BytesIO
        data_stream = io.BytesIO(response.content)
        data = pickle.load(data_stream)
        return data
    except requests.exceptions.RequestException as e:
        st.error(f"Error fetching file from GitHub: {e}")
        return None
    except pickle.UnpicklingError as e:
        st.error(f"Error unpickling data. The file might be corrupted or not a valid pickle file: {e}")
        return None
    except Exception as e:
        st.error(f"An unexpected error occurred: {e}")
        return None

# --- Main Application Logic ---
def main():
    st.title("ðŸ›’ Market Basket Analysis: Eclat Results")
    st.markdown(f"""
    This application visualizes frequent itemsets generated by the Eclat algorithm.
    **Data Source:** [GitHub Repository]({GITHUB_URL})
    """)

    with st.spinner('Fetching data from GitHub...'):
        raw_data = load_data_from_github(GITHUB_URL)

    if raw_data:
        # Handle dictionary keys
        if isinstance(raw_data, dict):
            if 'support_dictionary' in raw_data:
                support_data = raw_data['support_dictionary']
            elif 'frequent_itemsets' in raw_data:
                support_data = raw_data['frequent_itemsets']
            else:
                st.warning("Could not identify 'support_dictionary' key. Displaying raw keys.")
                st.write(raw_data.keys())
                return
        else:
            support_data = raw_data

        # Process Data into DataFrame
        try:
            items = []
            supports = []
            
            for itemset, support in support_data.items():
                # Handle if itemset is tuple/frozenset or string
                if isinstance(itemset, (tuple, frozenset, list)):
                    items.append(", ".join(list(itemset)))
                else:
                    items.append(str(itemset))
                supports.append(support)

            df = pd.DataFrame({'Itemset': items, 'Support': supports})
            df = df.sort_values(by='Support', ascending=False).reset_index(drop=True)

        except Exception as e:
            st.error(f"Error processing data structure: {e}")
            return

        # --- Sidebar Filters ---
        st.sidebar.header("Filter Results")

        if not df.empty:
            min_support = df['Support'].min()
            max_support = df['Support'].max()
            
            selected_min_support = st.sidebar.slider(
                "Minimum Support Threshold",
                min_value=float(min_support),
                max_value=float(max_support),
                value=float(min_support),
                format="%.4f"
            )

            unique_items = set()
            for item_str in df['Itemset']:
                for single_item in item_str.split(", "):
                    unique_items.add(single_item)
            
            selected_items = st.sidebar.multiselect(
                "Filter by Specific Item(s)",
                options=sorted(list(unique_items))
            )

            # --- Apply Filters ---
            filtered_df = df[df['Support'] >= selected_min_support]

            if selected_items:
                # Show itemsets that contain ANY of the selected items
                mask = filtered_df['Itemset'].apply(lambda x: any(item in x for item in selected_items))
                filtered_df = filtered_df[mask]

            # --- Dashboard Metrics ---
            col1, col2, col3 = st.columns(3)
            col1.metric("Total Itemsets", len(df))
            col2.metric("Filtered Itemsets", len(filtered_df))
            
            if not filtered_df.empty:
                current_max_support = filtered_df['Support'].max()
                col3.metric("Highest Support (Visible)", f"{current_max_support:.4f}")
            else:
                col3.metric("Highest Support (Visible)", "0.0000")

            # --- Visualizations ---
            st.subheader(f"Top Frequent Itemsets (Support >= {selected_min_support:.4f})")
            
            tab1, tab2 = st.tabs(["ðŸ“Š Bar Chart", "ðŸ“„ Data Table"])

            with tab1:
                if not filtered_df.empty:
                    # Limit to top 20 for readability in chart
                    top_n = 20
                    chart_df = filtered_df.head(top_n)
                    
                    fig = px.bar(
                        chart_df,
                        x='Support',
                        y='Itemset',
                        orientation='h',
                        title=f"Top {top_n} Frequent Itemsets",
                        color='Support',
                        color_continuous_scale='Viridis'
                    )
                    fig.update_layout(yaxis={'categoryorder': 'total ascending'})
                    st.plotly_chart(fig, use_container_width=True)
                else:
                    st.info("No itemsets meet the current filter criteria.")

            with tab2:
                st.dataframe(
                    filtered_df.style.background_gradient(subset=['Support'], cmap="Greens"),
                    use_container_width=True
                )
        else:
            st.warning("Dataframe is empty.")
    else:
        st.error("Failed to load data.")

if __name__ == "__main__":
    main()
